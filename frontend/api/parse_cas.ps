// frontend/api/parse_cas.js
import pdf from "pdf-parse";
import Busboy from "busboy";

/**
 * Vercel serverless function to parse CAS PDFs.
 * - Endpoint: POST /api/parse_cas
 * - Accepts multipart/form-data with field name "file" and optional "password"
 *
 * IMPORTANT: Place this file inside your frontend folder under `api/parse_cas.js`
 * (i.e., frontend/api/parse_cas.js) so Vercel exposes it at https://<your-site>/api/parse_cas
 */

function safeFloat(str) {
  if (!str && str !== 0) return null;
  const s = String(str).replace(/[₹,Rs\s]/gi, "").trim();
  const v = parseFloat(s.replace(/,/g, ""));
  return Number.isFinite(v) ? v : null;
}

function classifyByNameOrISIN(name = "", isin = "") {
  const n = (name || "").toLowerCase();
  if (isin && /^in(e|d)/i.test(isin)) return "Stocks";
  if (isin && /^inf/i.test(isin)) return "Mutual Funds";
  if (/sovereign gold bond|sgb|sovereign gold/i.test(n)) return "SGB";
  if (/re(it)?|reit|invit/i.test(n)) return "REIT/INVIT";
  if (/\b(etf|exchange traded)\b/i.test(n)) return "ETF";
  if (/\b(bond|gilt|debenture|non-convertible|ncd|corporate)\b/i.test(n)) return "Bonds";
  if (/\b(nps|national pension|pension)\b/i.test(n)) return "NPS";
  if (/\b(fund|mf|scheme|growth|index|largecap|midcap|smallcap|flexi|equity)\b/i.test(n)) return "Mutual Funds";
  return "Others";
}

function parseLineTokens(line) {
  const raw = line.replace(/\u00A0/g, " ").trim();
  const isinMatch = raw.match(/\b(IN[A-Z0-9]{9,13}|INF[A-Z0-9]{6,12})\b/i);
  const isin = isinMatch ? isinMatch[0] : null;

  const valueMatches = [...raw.matchAll(/(?:₹|Rs\.?|INR)?\s*([0-9]+(?:[.,][0-9]{2,3})?(?:[,0-9]*))\b/g)];
  let current_value = null;
  if (valueMatches.length) {
    const v = valueMatches[valueMatches.length - 1][1];
    current_value = safeFloat(v);
  }

  const unitMatch = raw.match(/\b([0-9]{1,3}(?:,[0-9]{3})*(?:\.[0-9]+)?)\s*(?:units|units\.|unit|qty|no\.|nos|shares|shares\.)?\b/i);
  const units = unitMatch ? parseFloat(unitMatch[1].replace(/,/g, "")) : null;

  const folioMatch = raw.match(/\bFolio\s*No\.?\s*[:\-]?\s*([A-Za-z0-9\-\/]+)\b/i) || raw.match(/\bFolio[:\s]([A-Za-z0-9\-\/]+)\b/i);
  const folio = folioMatch ? folioMatch[1] : null;

  const firstNumIdx = raw.search(/\d/);
  const schemeGuess = firstNumIdx > 0 ? raw.slice(0, firstNumIdx).replace(/(Folio|ISIN|INR|₹|Rs\.?)/ig, "").trim() : raw;

  return { raw, isin, folio, units, current_value, schemeGuess };
}

async function extractCASFromText(fullText) {
  const pages = fullText.split(/\f/);
  const results = [];

  for (let p = 0; p < pages.length; p++) {
    const pageText = pages[p] || "";
    const lines = pageText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      if (ln.length < 6) continue;

      // Block detection: scheme / folio / units / NAV headers
      if (/Scheme\s*Name|Scheme|ISIN|Folio|Units|Current Value|NAV|Holding Statement/i.test(ln)) {
        const block = [ln];
        if (i + 1 < lines.length) block.push(lines[i + 1]);
        if (i + 2 < lines.length) block.push(lines[i + 2]);
        const joined = block.join(" | ");
        const parsed = parseLineTokens(joined);
        if (parsed.isin || parsed.current_value || parsed.units) {
          const category = classifyByNameOrISIN(parsed.schemeGuess, parsed.isin);
          results.push({ page: p + 1, name: parsed.schemeGuess, isin: parsed.isin, folio: parsed.folio, units: parsed.units, current_value: parsed.current_value, category, raw: parsed.raw });
        }
        continue;
      }

      // Lines containing ISIN or many digits + currency -> likely holdings
      if (/\bIN[A-Z0-9]{9,13}\b/i.test(ln) || /\bINF[A-Z0-9]{6,12}\b/i.test(ln) || (((ln.match(/[0-9]/g)||[]).length > 6) && /[₹,\.]/.test(ln))) {
        const parsed = parseLineTokens(ln);
        const category = classifyByNameOrISIN(parsed.schemeGuess, parsed.isin);
        if (parsed.isin || parsed.current_value || parsed.units) {
          results.push({ page: p + 1, name: parsed.schemeGuess, isin: parsed.isin, folio: parsed.folio, units: parsed.units, current_value: parsed.current_value, category, raw: parsed.raw });
        }
      }

      // Table-like rows separated by double spaces
      if (/\s{2,}/.test(ln)) {
        const cols = ln.split(/\s{2,}/).map(s => s.trim()).filter(Boolean);
        const last = cols[cols.length - 1];
        if (/\d/.test(last)) {
          const scheme = cols[0];
          const cur = safeFloat(last);
          const maybeISIN = cols.find(c => /\bIN[A-Z0-9]{9,13}\b/i.test(c) || /\bINF[A-Z0-9]{6,12}\b/i.test(c));
          const isin = maybeISIN ? maybeISIN.match(/\b(IN[A-Z0-9]{9,13}|INF[A-Z0-9]{6,12})\b/i)[0] : null;
          const category = classifyByNameOrISIN(scheme, isin);
          results.push({ page: p + 1, name: scheme, isin, folio: null, units: null, current_value: cur, category, raw: ln });
        }
      }
    }
  }

  // dedupe & normalize
  const merged = [];
  const seen = new Set();
  for (const r of results) {
    const key = (r.isin || r.name || "") + "|" + (r.current_value || "") + "|" + (r.page || "");
    if (seen.has(key)) continue;
    seen.add(key);
    merged.push(r);
  }
  return merged;
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    res.status(405).json({ status: "error", message: "Method not allowed" });
    return;
  }

  // busboy to parse multipart (works in serverless)
  const contentType = req.headers["content-type"] || "";
  if (!contentType.startsWith("multipart/form-data")) {
    res.status(400).json({ status: "error", message: "Expected multipart/form-data" });
    return;
  }

  try {
    const bb = new Busboy({ headers: req.headers });
    let fileBuffer = null;
    let password = null;

    await new Promise((resolve, reject) => {
      bb.on("file", (name, stream, info) => {
        const chunks = [];
        stream.on("data", (c) => chunks.push(c));
        stream.on("end", () => {
          fileBuffer = Buffer.concat(chunks);
        });
        stream.on("error", reject);
      });
      bb.on("field", (name, val) => {
        if (name === "password") password = val;
      });
      bb.on("error", reject);
      bb.on("finish", resolve);
      req.pipe(bb);
    });

    if (!fileBuffer) {
      res.status(400).json({ status: "error", message: "No file uploaded" });
      return;
    }

    // parse pdf text using pdf-parse
    const data = await pdf(fileBuffer, password ? { password } : {});
    const text = data.text || "";
    const parsed = await extractCASFromText(text);

    const summary = parsed.reduce((acc, it) => {
      acc[it.category] = (acc[it.category] || 0) + 1;
      return acc;
    }, {});

    res.json({ status: "ok", count: parsed.length, summary, data: parsed });
  } catch (err) {
    console.error("Parse error:", err);
    res.status(500).json({ status: "error", message: String(err) });
  }
}
